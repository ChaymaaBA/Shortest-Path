# -*- coding: utf-8 -*-
"""shortestpath.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ej6ZlKr4BHcG8ywwIHps7rDOBkwqpn82
"""

import numpy as np
import matplotlib.pyplot as plt
import heapq

# Generate grid (waypoints)
grid_size = 10
x = np.linspace(0, 10, grid_size)
y = np.linspace(0, 10, grid_size)
xx, yy = np.meshgrid(x, y)
grid_points = np.c_[xx.ravel(), yy.ravel()]

# Generate thermals
num_thermals = 7
thermals_x = np.random.uniform(0, 10, num_thermals)
thermals_y = np.random.uniform(0, 10, num_thermals)
elevations = np.random.choice([1, 2, 4], num_thermals)  # Weak (1), Medium (2), Strong (4)
thermals = np.c_[thermals_x, thermals_y, elevations]

# Function to calculate cost (energy + thermal rewards)
def calculate_cost(path, thermals):
    total_cost = 0
    for i in range(len(path) - 1):
        # Energy cost (distance)
        dist = np.linalg.norm(np.array(path[i]) - np.array(path[i + 1]))
        total_cost += dist

        # Reward for thermals
        midpoint = ((path[i][0] + path[i + 1][0]) / 2, (path[i][1] + path[i + 1][1]) / 2)
        for thermal in thermals:
            if np.linalg.norm(midpoint - np.array(thermal[:2])) < 1.5:  # Within radius
                if thermal[2] == 4:  # Strong thermal
                    total_cost -= 15  # Higher reward for strong thermals
                elif thermal[2] == 2:  # Medium thermal
                    total_cost -= 8  # Medium reward for medium thermals
    return total_cost

# A* algorithm
def a_star(grid_points, thermals, start, end):
    open_list = []
    heapq.heappush(open_list, (0, [tuple(start)]))  # Start with the tuple form of `start`
    visited = set()

    while open_list:
        cost, path = heapq.heappop(open_list)
        current = path[-1]

        # Check if the current point matches the end point
        if current == tuple(end):
            return path, cost

        if current in visited:
            continue
        visited.add(current)

        # Explore neighbors (restrict to nearby points)
        for neighbor in grid_points:
            if np.linalg.norm(np.array(current) - neighbor) <= 2:  # Restrict to nearby points
                neighbor_tuple = tuple(neighbor)
                if neighbor_tuple not in visited:
                    new_path = path + [neighbor_tuple]
                    new_cost = calculate_cost(new_path, thermals)
                    heapq.heappush(open_list, (new_cost, new_path))

    return None, float('inf')

# Define start and end points
start_point = (0, 0)
end_point = (10, 10)

# Find the optimal path
optimal_path, total_cost = a_star(grid_points, thermals, start_point, end_point)

# Plot the grid, thermals, and optimal path
plt.scatter(grid_points[:, 0], grid_points[:, 1], c='blue', label='Waypoints (Grid)')
for thermal in thermals:
    if thermal[2] == 4:
        plt.scatter(thermal[0], thermal[1], c='red', label='Thermal (4.0 m/s)')
    elif thermal[2] == 2:
        plt.scatter(thermal[0], thermal[1], c='orange', label='Thermal (2.0 m/s)')
    else:
        plt.scatter(thermal[0], thermal[1], c='yellow', label='Thermal (1.0 m/s)')

optimal_path = np.array(optimal_path)
plt.plot(optimal_path[:, 0], optimal_path[:, 1], color='green', marker='o', label='Optimized Path')

plt.title('Optimized UAV Trajectory (Grid with Thermal Coverage)')
plt.xlabel('X')
plt.ylabel('Y')
plt.legend(loc='best')
plt.grid(True)
plt.show()

print("Optimal Path:", optimal_path.tolist())
print("Total Energy Cost:", total_cost)

def genetic_algorithm(grid_points, thermals, start, end, population_size=20, generations=100, mutation_rate=0.2):
    # Generate initial population
    def generate_initial_population():
        population = []
        for _ in range(population_size):
            path = [start]
            for _ in range(len(grid_points) // 10):  # Add intermediate points
                thermal_candidates = thermals[np.random.choice(len(thermals), 2, replace=False)]
                path.append(tuple(thermal_candidates[np.random.randint(len(thermal_candidates))][:2]))
            path.append(end)
            population.append(path)
        return population

    # Mutation: Randomly modify part of a path
    def mutate(path):
        idx = np.random.randint(1, len(path) - 1)
        new_path = path.copy()
        new_path[idx] = tuple(grid_points[np.random.randint(len(grid_points))])
        return new_path

    # Crossover: Combine two parent paths
    def crossover(parent1, parent2):
        idx = np.random.randint(1, len(parent1) - 1)
        return parent1[:idx] + parent2[idx:]

    # Evaluate population fitness
    def evaluate_population(population):
        return sorted(population, key=lambda p: calculate_cost(p, thermals))

    # Initialize population
    population = generate_initial_population()

    for generation in range(generations):
        # Evaluate fitness
        population = evaluate_population(population)

        # Elitism: Retain the top 10%
        next_generation = population[:population_size // 10]

        # Generate new population
        while len(next_generation) < population_size:
            if np.random.rand() < mutation_rate:
                parent = population[np.random.randint(len(population))]
                next_generation.append(mutate(parent))
            else:
                parent1 = population[np.random.randint(len(population))]
                parent2 = population[np.random.randint(len(population))]
                next_generation.append(crossover(parent1, parent2))

        # Replace old population
        population = next_generation

    # Return the best solution
    best_path = evaluate_population(population)[0]
    best_cost = calculate_cost(best_path, thermals)
    return best_path, best_cost

# Dijkstra's Algorithm Implementation
def dijkstra(grid_points, thermals, start, end):
    visited = set()
    open_list = [(0, [start])]  # (cost, path)

    while open_list:
        cost, path = heapq.heappop(open_list)
        current = tuple(path[-1])

        if current in visited:
            continue
        visited.add(current)

        # Check if the end point is reached
        if current == tuple(end):
            return path, cost

        # Explore neighbors
        for neighbor in grid_points:
            if np.linalg.norm(np.array(current) - neighbor) <= 2:  # Restrict to nearby points
                neighbor_tuple = tuple(neighbor)
                if neighbor_tuple not in visited:
                    new_path = path + [neighbor_tuple]
                    new_cost = calculate_cost(new_path, thermals)
                    heapq.heappush(open_list, (new_cost, new_path))

    return None, float('inf')

# Define start and end points
start_point = (0, 0)
end_point = (10, 10)

# Run A* Algorithm
optimal_path_a_star, total_cost_a_star = a_star(grid_points, thermals, start_point, end_point)

# Run Genetic Algorithm
optimal_path_genetic, total_cost_genetic = genetic_algorithm(grid_points, thermals, start_point, end_point)

# Run Dijkstra's Algorithm
optimal_path_dijkstra, total_cost_dijkstra = dijkstra(grid_points, thermals, start_point, end_point)

# Visualization
def plot_results(grid_points, thermals, paths, costs, titles):
    plt.figure(figsize=(18, 6))
    for i, (path, cost, title) in enumerate(zip(paths, costs, titles)):
        plt.subplot(1, 3, i + 1)
        plt.scatter(grid_points[:, 0], grid_points[:, 1], c='blue', label='Waypoints (Grid)')
        for thermal in thermals:
            color = 'red' if thermal[2] == 4 else 'orange' if thermal[2] == 2 else 'yellow'
            plt.scatter(thermal[0], thermal[1], c=color, label=f'Thermal ({thermal[2]} m/s)')
        path = np.array(path)
        plt.plot(path[:, 0], path[:, 1], color='green', marker='o', label='Optimized Path')
        plt.title(f'{title}\nCost: {cost:.2f}')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.legend()
        plt.grid(True)
    plt.tight_layout()
    plt.show()

# Plot results
plot_results(
    grid_points, thermals,
    [optimal_path_a_star, optimal_path_genetic, optimal_path_dijkstra],
    [total_cost_a_star, total_cost_genetic, total_cost_dijkstra],
    ['A* Algorithm', 'Genetic Algorithm', "Dijkstra's Algorithm"]
)